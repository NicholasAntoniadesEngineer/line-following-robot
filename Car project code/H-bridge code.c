/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 7.1.1   2017-03-29

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/
/*==========================================================================*
 * 																			*
 * 					EEE3017W: DIGITAL ELECTRONICS - 2017					*
 * 								PRACTICAL 1									*
 * 																			*
 *==========================================================================*
 *
 *	Group #:
 *
 *	Student #1:
 *	Student #2:
 *
 ****************************************************************************
 */
//==========================================================================*
//	INCLUDES
//==========================================================================*
	/*Include your header files here*/

#include "stm32f0xx.h"
#include "lcd_stm32f0.h"
//==========================================================================*
//	MACROS
//==========================================================================*
	/*Define your macros here*/
#define GPIO_AFRH_AFR10_AF2 ((uint32_t)0x00000200)
#define GPIO_AFRH_AFR11_AF2 ((uint32_t)0x00002000)
#define GPIO_AF2 ((uint32_t)0x00000002)
//==========================================================================*
//	GLOBAL CONSTANTS
//==========================================================================*
	/*Define your global constants here*/

//==========================================================================*
//	GLOBAL VARIABLES
//==========================================================================*
	/*Define your global variables here*/

//==========================================================================*
//	FUNCTION PROTOTYPES
//==========================================================================*
	/*Declare your functions here*/
	void init_Ports(void);
	void init_ADC(void);
	void init_PWM(void);
	int ADC_POT(int pot, int resolution);
	int ADC_DATA(void);
	void delay_ms (uint32_t counter);
	void softstart(void);

//==========================================================================*
//	FUNCTIONS
//==========================================================================*

	/*Write your function descriptions here*/
	void init_Ports(void)
	{
		RCC-> AHBENR |= RCC_AHBENR_GPIOBEN;
		GPIOB-> MODER |= GPIO_MODER_MODER0_0;
		GPIOB-> MODER |= GPIO_MODER_MODER1_0;
		GPIOB-> MODER |= GPIO_MODER_MODER2_0;
		GPIOB-> MODER |= GPIO_MODER_MODER3_0;
		GPIOB-> MODER |= GPIO_MODER_MODER4_0;
		GPIOB-> MODER |= GPIO_MODER_MODER5_0;
		GPIOB-> MODER |= GPIO_MODER_MODER6_0;
		GPIOB-> MODER |= GPIO_MODER_MODER7_0;
		GPIOB-> MODER |= GPIO_MODER_MODER12_0;


		RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
		GPIOA->MODER &=~ GPIO_MODER_MODER0;
		GPIOA->MODER &=~ GPIO_MODER_MODER1;
		GPIOA->MODER &=~ GPIO_MODER_MODER2;
		GPIOA->MODER &=~ GPIO_MODER_MODER3;
		GPIOA->PUPDR |= GPIO_PUPDR_PUPDR0_0;
		GPIOA->PUPDR |= GPIO_PUPDR_PUPDR1_0;
		GPIOA->PUPDR |= GPIO_PUPDR_PUPDR2_0;
		GPIOA->PUPDR |= GPIO_PUPDR_PUPDR3_0;
	}
	void init_ADC(void)
		{
		RCC -> APB2ENR |= RCC_APB2ENR_ADCEN; //Enabling the ADC clock in the RCC APB  periperal clock enableregister
		ADC1 -> CFGR1 |= 0x10;               //Setting the ADC resolution in the ADC configuration register 1
		ADC1->CHSELR = 0b100000;				 // Selecting the chanel for pot-0.
		ADC1 -> CR |= ADC_CR_ADEN;           //Enabling the ADC
		while((ADC1 -> ISR & 0x01) ==0 );    //Waiting for the ADRDY pin to let us know the ADC is ready.
		}
	void init_PWM(void){
		/*Macros to be defined*/
		//#define GPIO_AFRH_AFR10_AF2 ((uint32_t)0x00000200)
		//#define GPIO_AFRH_AFR11_AF2 ((uint32_t)0x00002000)


		//Initialising clocks and pins for PWM output
		RCC->AHBENR |= RCC_AHBENR_GPIOBEN; 	  // Enable clock for GPIOB
		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;	  // Enable TIM2
		GPIOB->MODER |= GPIO_MODER_MODER10_1; // set PB10 to AF
		GPIOB->MODER |= GPIO_MODER_MODER11_1; // set PB11 to AF

		//Choosing AF for pins, MAPPING them to TIM2 CH3 and CH4
		GPIOB->AFR[1] |= (GPIO_AFRH_AFR10_AF2&(GPIO_AF2<<8)); //Enable AF2 for PB10 in GPIOB AFR10
		GPIOB->AFR[1] |= (GPIO_AFRH_AFR11_AF2&(GPIO_AF2<<12));//Enable AF2 for PB11 in GPIOB AFR11

		//Setting signal frequency
		TIM2->ARR = 48000; // ARR = 48000 for f =1kHz
		TIM2->PSC = 0;

		// specify PWM mode: OCxM bits in CCMRx. We want mode 1
		TIM2->CCMR2 |= (TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3M_1); // PWM Mode 1
		TIM2->CCMR2 |= (TIM_CCMR2_OC4M_2 | TIM_CCMR2_OC4M_1); // PWM Mode 1

		//PWM Duty cycle based on fractions of ARR
		TIM2->CCR3 = 0 * 480; // Red = 20%
		TIM2->CCR4 = 20 * 480; // Green = 90%

		// Enable output compare for CH3 and CH4
		TIM2->CCER |= TIM_CCER_CC3E; //Compare 3 output enable
		TIM2->CCER |= TIM_CCER_CC4E; //Compare 4 output enable
		TIM2->CR1 |= TIM_CR1_CEN;    //Counter enable
		}
	int ADC_POT(int pot, int resolution){
	    /* configure resolution,
	    0: 12 bits
	    1: 10 bits
	    2: 8 bits
	    3: 6 bits */
	    ADC1->CFGR1 |= (resolution << 3);
	    // channel select where Pot0 = PA5, Pot1 = PA6
	    ADC1->CHSELR = (1 << (5 + pot));
	    // start conversion
	    ADC1->CR |= (0b1 << 2);
	    // wait for conversion
	    while ((ADC1->ISR & 0b100) == 0);
	    //return value
	    return ADC1->DR;
	}
	int ADC_DATA(void)
		{
		ADC1 ->CR |= ADC_CR_ADSTART;		// Starts ADC conversion
		while((ADC1 -> ISR & 0b100) ==0 );	// Waits for the End of conversion flag to be set
		return ADC1 -> DR;
		}
	void delay_ms (uint32_t delaylength)
	{
		int counter = delaylength*735;
		while(counter>0)
		{
			counter--;
		}
	}
	void softstart(void)
	{
		//Soft start for PWM on PB10 and PB11
		//Linear increase of PWM from 0->100%

		/*Neccesary initializations*/
		//init_PWM();

		int i;
		int j;
		float percent_j;

		TIM2->CCR4 = 0;
		TIM2->CCR3 = 0;

	  while (1)
	  {
		  for(i = 1; i<40000;i++){
			  percent_j = (i/40000.0);
			  j = percent_j*100;
			  TIM2->CCR3 = j*400;
			  TIM2->CCR4 = j*480;
		  }
			/*i = 0;
			percent_j = 0;
			j = 0;
			TIM2->CCR4 = 0;
			TIM2->CCR3 = 0;*/
	 }
	 }
	void Pot_PWM(void){

		int P0;
		int P1;
		float P0_val;
		float P1_val;
		float percentage_P0;
		float percentage_P1;

		while(1){
			P0_val = ADC_POT(0,8);
			P1_val = ADC_POT(1,8);
			percentage_P0 = P0_val/252;
			percentage_P1 = P1_val/252;
			P0 = percentage_P0*100;
			P1 = percentage_P1*100;

			//At P0 = 1OO, P0*48 = ARR value, this is 100% duty cylce.
			//48 will change according to ARR value
			TIM2->CCR3 = P0 * 480;
			TIM2->CCR4 = P1 * 480;
		}

	}
//==========================================================================*

/****************************************************************************
/*
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void){
	init_Ports();
	init_ADC();
	init_PWM();
	Pot_PWM();
	  while (1)
	  {
	  }


}















